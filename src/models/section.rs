//! Contains structs and functions for doing operations on sections.
//!
//! A section represents a section of a template for a report file to be generated from a run.
//! Represented in the database by the SECTION table.

use crate::custom_sql_types::{ReportStatusEnum, REPORT_FAILURE_STATUSES};
use crate::schema::report_section;
use crate::schema::run_report;
use crate::schema::section;
use crate::schema::section::dsl::*;
use crate::util;
use chrono::NaiveDateTime;
use core::fmt;
use diesel::dsl::{all, any};
use diesel::prelude::*;
use log::error;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

/// Mapping to a section as it exists in the SECTION table in the database.
///
/// An instance of this struct will be returned by any queries for sections.
#[derive(Queryable, Serialize, Deserialize, PartialEq, Debug)]
pub struct SectionData {
    pub section_id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub contents: Value,
    pub created_at: NaiveDateTime,
    pub created_by: Option<String>,
}

/// Represents all possible parameters for a query of the SECTION table
///
/// All values are optional, so any combination can be used during a query.  Limit and offset are
/// used for pagination.  Sort expects a comma-separated list of sort keys, optionally enclosed
/// with either asc() or desc().  For example: asc(name),desc(description),section_id
#[derive(Deserialize, Serialize)]
pub struct SectionQuery {
    pub section_id: Option<Uuid>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub contents: Option<Value>,
    pub created_before: Option<NaiveDateTime>,
    pub created_after: Option<NaiveDateTime>,
    pub created_by: Option<String>,
    pub sort: Option<String>,
    pub limit: Option<i64>,
    pub offset: Option<i64>,
}

/// A new section to be inserted into the DB
///
/// name and contents are required fields, but description and created_by are not, so can be filled
/// with `None`
/// section_id and created_at are populated automatically by the DB
#[derive(Deserialize, Insertable, Serialize)]
#[table_name = "section"]
pub struct NewSection {
    pub name: String,
    pub description: Option<String>,
    pub contents: Value,
    pub created_by: Option<String>,
}

/// Represents fields to change when updating a section
///
/// Only description can be modified if there is a report with a non-failed run report associated
/// with the specified section.  If there is not, contents can also be modified
#[derive(Deserialize, Serialize, AsChangeset, Debug)]
#[table_name = "section"]
pub struct SectionChangeset {
    pub name: Option<String>,
    pub description: Option<String>,
    pub contents: Option<Value>,
}

/// Represents an error generated by an attempt at updating a row in the SECTION table
///
/// Updates can fail either because of a diesel error or because some of the parameters to be
/// updated are not allowed to be updated
#[derive(Debug)]
pub enum UpdateError {
    DB(diesel::result::Error),
    Prohibited(String),
}

impl std::error::Error for UpdateError {}

impl fmt::Display for UpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            UpdateError::DB(e) => write!(f, "UpdateError DB {}", e),
            UpdateError::Prohibited(e) => write!(f, "UpdateError Prohibited {}", e),
        }
    }
}

impl From<diesel::result::Error> for UpdateError {
    fn from(e: diesel::result::Error) -> UpdateError {
        UpdateError::DB(e)
    }
}

impl SectionData {
    /// Queries the DB for a section with the specified id
    ///
    /// Queries the DB using `conn` to retrieve the first row with a section_id value of `id`
    /// Returns a result containing either the retrieved section as a SectionData instance
    /// or an error if the query fails for some reason or if no section is found matching the
    /// criteria
    pub fn find_by_id(conn: &PgConnection, id: Uuid) -> Result<Self, diesel::result::Error> {
        section.filter(section_id.eq(id)).first::<Self>(conn)
    }

    /// Queries the DB for sections matching the specified query criteria
    ///
    /// Queries the DB using `conn` to retrieve sections matching the criteria in `params`
    /// Returns a result containing either a vector of the retrieved sections as SectionData
    /// instances or an error if the query fails for some reason
    pub fn find(
        conn: &PgConnection,
        params: SectionQuery,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        // Put the query into a box (pointer) so it can be built dynamically
        let mut query = section.into_boxed();

        // Add filters for each of the params if they have values
        if let Some(param) = params.section_id {
            query = query.filter(section_id.eq(param));
        }
        if let Some(param) = params.name {
            query = query.filter(name.eq(param));
        }
        if let Some(param) = params.description {
            query = query.filter(description.eq(param));
        }
        if let Some(param) = params.contents {
            query = query.filter(contents.eq(param));
        }
        if let Some(param) = params.created_before {
            query = query.filter(created_at.lt(param));
        }
        if let Some(param) = params.created_after {
            query = query.filter(created_at.gt(param));
        }
        if let Some(param) = params.created_by {
            query = query.filter(created_by.eq(param));
        }

        // If there is a sort param, parse it and add to the order by clause accordingly
        if let Some(sort) = params.sort {
            let sort = util::parse_sort_string(&sort);
            for sort_clause in sort {
                match &*sort_clause.key {
                    "section_id" => {
                        if sort_clause.ascending {
                            query = query.then_order_by(section_id.asc());
                        } else {
                            query = query.then_order_by(section_id.desc());
                        }
                    }
                    "name" => {
                        if sort_clause.ascending {
                            query = query.then_order_by(name.asc());
                        } else {
                            query = query.then_order_by(name.desc());
                        }
                    }
                    "description" => {
                        if sort_clause.ascending {
                            query = query.then_order_by(description.asc());
                        } else {
                            query = query.then_order_by(description.desc());
                        }
                    }
                    "contents" => {
                        if sort_clause.ascending {
                            query = query.then_order_by(contents.asc());
                        } else {
                            query = query.then_order_by(contents.desc());
                        }
                    }
                    "created_at" => {
                        if sort_clause.ascending {
                            query = query.then_order_by(created_at.asc());
                        } else {
                            query = query.then_order_by(created_at.desc());
                        }
                    }
                    "created_by" => {
                        if sort_clause.ascending {
                            query = query.then_order_by(created_by.asc());
                        } else {
                            query = query.then_order_by(created_by.desc());
                        }
                    }
                    // Don't add to the order by clause if the sort key isn't recognized
                    &_ => {}
                }
            }
        }

        if let Some(param) = params.limit {
            query = query.limit(param);
        }
        if let Some(param) = params.offset {
            query = query.offset(param);
        }

        // Perform the query
        query.load::<Self>(conn)
    }

    /// Inserts a new section into the DB
    ///
    /// Creates a new section row in the DB using `conn` with the values specified in `params`
    /// Returns a result containing either the new section that was created or an error if the
    /// insert fails for some reason
    pub fn create(conn: &PgConnection, params: NewSection) -> Result<Self, diesel::result::Error> {
        diesel::insert_into(section)
            .values(&params)
            .get_result(conn)
    }

    /// Updates a specified section in the DB
    ///
    /// Updates the section row in the DB using `conn` specified by `id` with the values in
    /// `params`.  Update fails if trying to update contents when there exists a non failed
    /// run_report for a report associated with this section
    /// Returns a result containing either the newly updated section or an error if the update
    /// fails for some reason
    pub fn update(
        conn: &PgConnection,
        id: Uuid,
        params: SectionChangeset,
    ) -> Result<Self, UpdateError> {
        // If trying to update contents, verify that no non-failed run_reports exist for a report
        // related to this section
        if matches!(params.contents, Some(_)) || matches!(params.name, Some(_)) {
            // Subquery for getting all report_ids for reports mapped to the specified section
            let report_section_subquery = report_section::dsl::report_section
                .filter(report_section::dsl::section_id.eq(id))
                .select(report_section::dsl::report_id);
            // Query the run table
            let non_failed_run_reports_count = run_report::dsl::run_report
                .filter(run_report::dsl::report_id.eq(any(report_section_subquery)))
                .filter(
                    run_report::dsl::status.ne(all(REPORT_FAILURE_STATUSES
                        .iter()
                        .cloned()
                        .collect::<Vec<ReportStatusEnum>>())),
                )
                .select(run_report::dsl::run_id)
                .first::<Uuid>(conn);
            match non_failed_run_reports_count {
                // If there is a nonfailed run_report, return an error
                Ok(_) => {
                    let err = UpdateError::Prohibited(String::from("Attempted to update contents when a non-failed run_report already exists for a report to which this section is mapped.  Doing so is prohibited"));
                    error!("Failed to update due to error: {}", err);
                    return Err(err);
                }
                // If there are no nonfailed run_reports, don't stop execution
                Err(diesel::result::Error::NotFound) => {}
                // If checking for run_reports failed for some reason, return the error
                Err(e) => {
                    error!("Failed to update due to error: {}", e);
                    return Err(UpdateError::DB(e));
                }
            }
        }
        Ok(diesel::update(section.filter(section_id.eq(id)))
            .set(params)
            .get_result(conn)?)
    }

    /// Deletes a specific section in the DB
    ///
    /// Deletes the section row in the DB using `conn` specified by `id`
    /// Returns a result containing either the number of rows deleted or an error if the delete
    /// fails for some reason
    pub fn delete(conn: &PgConnection, id: Uuid) -> Result<usize, diesel::result::Error> {
        diesel::delete(section.filter(section_id.eq(id))).execute(conn)
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use crate::custom_sql_types::RunStatusEnum;
    use crate::models::pipeline::{NewPipeline, PipelineData};
    use crate::models::report::{NewReport, ReportData};
    use crate::models::report_section::{NewReportSection, ReportSectionData};
    use crate::models::run::{NewRun, RunData};
    use crate::models::run_report::{NewRunReport, RunReportData};
    use crate::models::template::{NewTemplate, TemplateData};
    use crate::models::test::{NewTest, TestData};
    use crate::unit_test_util::*;
    use chrono::Utc;
    use serde_json::json;
    use uuid::Uuid;

    fn insert_test_section(conn: &PgConnection) -> SectionData {
        let new_section = NewSection {
            name: String::from("Kevin's Section"),
            description: Some(String::from("Kevin made this section for testing")),
            contents: json!({"cells":[{"test":"test"}]}),
            created_by: Some(String::from("Kevin@example.com")),
        };

        SectionData::create(conn, new_section).expect("Failed inserting test section")
    }

    fn insert_test_sections(conn: &PgConnection) -> Vec<SectionData> {
        let mut sections = Vec::new();

        let new_section = NewSection {
            name: String::from("Name1"),
            description: Some(String::from("Description4")),
            contents: json!({"cells":[{"test1":"test"}]}),
            created_by: Some(String::from("Test@example.com")),
        };

        sections
            .push(SectionData::create(conn, new_section).expect("Failed inserting test section"));

        let new_section = NewSection {
            name: String::from("Name2"),
            description: Some(String::from("Description3")),
            contents: json!({"cells":[{"test2":"test"}]}),
            created_by: Some(String::from("Test@example.com")),
        };

        sections
            .push(SectionData::create(conn, new_section).expect("Failed inserting test section"));

        let new_section = NewSection {
            name: String::from("Name4"),
            description: Some(String::from("Description3")),
            contents: json!({"cells":[{"test4":"test"}]}),
            created_by: Some(String::from("Test@example.com")),
        };

        sections
            .push(SectionData::create(conn, new_section).expect("Failed inserting test section"));

        sections
    }

    fn insert_test_report(conn: &PgConnection) -> ReportData {
        let new_report = NewReport {
            name: String::from("Kevin's Report"),
            description: Some(String::from("Kevin made this report for testing")),
            metadata: json!({"metadata":[{"test1":"test"}]}),
            created_by: Some(String::from("Kevin@example.com")),
        };

        ReportData::create(conn, new_report).expect("Failed inserting test report")
    }

    fn insert_test_report_section_with_section_id(
        conn: &PgConnection,
        id: Uuid,
    ) -> ReportSectionData {
        let new_report = NewReport {
            name: String::from("Kevin's Report"),
            description: Some(String::from("Kevin made this report for testing")),
            metadata: json!({"metadata":[{"test":"test"}]}),
            created_by: Some(String::from("Kevin@example.com")),
        };

        let report = ReportData::create(conn, new_report).expect("Failed inserting test report");

        let new_report_section = NewReportSection {
            section_id: id,
            report_id: report.report_id,
            name: String::from("Section 0"),
            position: 0,
            created_by: Some(String::from("Kevin@example.com")),
        };

        ReportSectionData::create(conn, new_report_section)
            .expect("Failed inserting test report_section")
    }

    fn insert_test_run(conn: &PgConnection) -> RunData {
        let new_pipeline = NewPipeline {
            name: String::from("Kevin's Pipeline 2"),
            description: Some(String::from("Kevin made this pipeline for testing 2")),
            created_by: Some(String::from("Kevin2@example.com")),
        };

        let pipeline =
            PipelineData::create(conn, new_pipeline).expect("Failed inserting test pipeline");

        let new_template = NewTemplate {
            name: String::from("Kevin's Template2"),
            pipeline_id: pipeline.pipeline_id,
            description: Some(String::from("Kevin made this template for testing2")),
            test_wdl: String::from("testtest"),
            eval_wdl: String::from("evaltest"),
            created_by: Some(String::from("Kevin2@example.com")),
        };

        let template =
            TemplateData::create(conn, new_template).expect("Failed inserting test template");

        let new_test = NewTest {
            name: String::from("Kevin's Test"),
            template_id: template.template_id,
            description: Some(String::from("Kevin made this test for testing")),
            test_input_defaults: Some(serde_json::from_str("{\"test\":\"test\"}").unwrap()),
            eval_input_defaults: Some(serde_json::from_str("{\"eval\":\"test\"}").unwrap()),
            created_by: Some(String::from("Kevin@example.com")),
        };

        let test = TestData::create(conn, new_test).expect("Failed inserting test test");

        let new_run = NewRun {
            test_id: test.test_id,
            name: String::from("Kevin's test run"),
            status: RunStatusEnum::Succeeded,
            test_input: serde_json::from_str("{\"test\":\"1\"}").unwrap(),
            eval_input: serde_json::from_str("{}").unwrap(),
            test_cromwell_job_id: Some(String::from("123456789")),
            eval_cromwell_job_id: Some(String::from("12345678902")),
            created_by: Some(String::from("Kevin@example.com")),
            finished_at: Some(Utc::now().naive_utc()),
        };

        RunData::create(&conn, new_run).expect("Failed to insert run")
    }

    fn insert_test_run_report_failed_with_report_id(
        conn: &PgConnection,
        id: Uuid,
    ) -> RunReportData {
        let run = insert_test_run(conn);

        let new_run_report = NewRunReport {
            run_id: run.run_id,
            report_id: id,
            status: ReportStatusEnum::Failed,
            cromwell_job_id: Some(String::from("testtesttesttest")),
            results: None,
            created_by: Some(String::from("Kevin@example.com")),
            finished_at: Some(Utc::now().naive_utc()),
        };

        RunReportData::create(conn, new_run_report).expect("Failed inserting test run_report")
    }

    fn insert_test_run_report_non_failed_with_report_id(
        conn: &PgConnection,
        id: Uuid,
    ) -> RunReportData {
        let run = insert_test_run(conn);

        let new_run_report = NewRunReport {
            run_id: run.run_id,
            report_id: id,
            status: ReportStatusEnum::Running,
            cromwell_job_id: Some(String::from("testtesttesttest")),
            results: None,
            created_by: Some(String::from("Kevin@example.com")),
            finished_at: None,
        };

        RunReportData::create(conn, new_run_report).expect("Failed inserting test run_report")
    }

    fn insert_test_report_sections_with_report_id(
        conn: &PgConnection,
        id: Uuid,
    ) -> (Vec<ReportSectionData>, Vec<SectionData>) {
        let mut report_sections = Vec::new();
        let mut sections = Vec::new();

        let new_section = NewSection {
            name: String::from("Name1"),
            description: Some(String::from("Description4")),
            contents: json!({"cells":[{"test1":"test"}]}),
            created_by: Some(String::from("Test@example.com")),
        };

        sections
            .push(SectionData::create(conn, new_section).expect("Failed inserting test section"));

        let new_report_section = NewReportSection {
            section_id: sections[0].section_id,
            report_id: id,
            name: String::from("Name1 1"),
            position: 1,
            created_by: Some(String::from("Kevin@example.com")),
        };

        report_sections.push(
            ReportSectionData::create(conn, new_report_section)
                .expect("Failed inserting test report_section"),
        );

        let new_section = NewSection {
            name: String::from("Name2"),
            description: Some(String::from("Description5")),
            contents: json!({"cells":[{"test2":"test"}]}),
            created_by: Some(String::from("Kevin@example.com")),
        };

        sections
            .push(SectionData::create(conn, new_section).expect("Failed inserting test section"));

        let new_report_section = NewReportSection {
            section_id: sections[1].section_id,
            report_id: id,
            name: String::from("Name2 2"),
            position: 2,
            created_by: Some(String::from("Kevin@example.com")),
        };

        report_sections.push(
            ReportSectionData::create(conn, new_report_section)
                .expect("Failed inserting test report_section"),
        );

        let new_section = NewSection {
            name: String::from("Name5"),
            description: Some(String::from("Description12")),
            contents: json!({"cells":[{"test5":"test"}]}),
            created_by: Some(String::from("Test@example.com")),
        };

        sections
            .push(SectionData::create(conn, new_section).expect("Failed inserting test section"));

        let new_report_section = NewReportSection {
            section_id: sections[2].section_id,
            report_id: id,
            name: String::from("Name5 3"),
            position: 3,
            created_by: Some(String::from("Kelvin@example.com")),
        };

        report_sections.push(
            ReportSectionData::create(conn, new_report_section)
                .expect("Failed inserting test report_section"),
        );

        (report_sections, sections)
    }

    #[test]
    fn find_by_id_exists() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);

        let found_section = SectionData::find_by_id(&conn, test_section.section_id)
            .expect("Failed to retrieve test section by id.");

        assert_eq!(found_section, test_section);
    }

    #[test]
    fn find_by_id_not_exists() {
        let conn = get_test_db_connection();

        let nonexistent_section = SectionData::find_by_id(&conn, Uuid::new_v4());

        assert!(matches!(
            nonexistent_section,
            Err(diesel::result::Error::NotFound)
        ));
    }

    #[test]
    fn find_with_section_id() {
        let conn = get_test_db_connection();

        let test_sections = insert_test_sections(&conn);

        let test_query = SectionQuery {
            section_id: Some(test_sections[0].section_id),
            name: None,
            description: None,
            contents: None,
            created_before: None,
            created_after: None,
            created_by: None,
            sort: None,
            limit: None,
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 1);
        assert_eq!(found_sections[0], test_sections[0]);
    }

    #[test]
    fn find_with_name() {
        let conn = get_test_db_connection();

        let test_sections = insert_test_sections(&conn);

        let test_query = SectionQuery {
            section_id: None,
            name: Some(test_sections[0].name.clone()),
            description: None,
            contents: None,
            created_before: None,
            created_after: None,
            created_by: None,
            sort: None,
            limit: None,
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 1);
        assert_eq!(found_sections[0], test_sections[0]);
    }

    #[test]
    fn find_with_description() {
        let conn = get_test_db_connection();

        let test_sections = insert_test_sections(&conn);

        let test_query = SectionQuery {
            section_id: None,
            name: None,
            description: Some(test_sections[0].description.clone().unwrap()),
            contents: None,
            created_before: None,
            created_after: None,
            created_by: None,
            sort: None,
            limit: None,
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 1);
        assert_eq!(found_sections[0], test_sections[0]);
    }

    #[test]
    fn find_with_contents() {
        let conn = get_test_db_connection();

        let test_sections = insert_test_sections(&conn);

        let test_query = SectionQuery {
            section_id: None,
            name: None,
            description: None,
            contents: Some(json!({"cells":[{"test1":"test"}]})),
            created_before: None,
            created_after: None,
            created_by: None,
            sort: None,
            limit: None,
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 1);
        assert_eq!(found_sections[0], test_sections[0]);
    }

    #[test]
    fn find_with_sort_and_limit_and_offset() {
        let conn = get_test_db_connection();

        let test_sections = insert_test_sections(&conn);

        let test_query = SectionQuery {
            section_id: None,
            name: None,
            description: None,
            contents: None,
            created_before: None,
            created_after: None,
            created_by: Some(String::from("Test@example.com")),
            sort: Some(String::from("description,desc(name)")),
            limit: Some(2),
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 2);
        assert_eq!(found_sections[0], test_sections[2]);
        assert_eq!(found_sections[1], test_sections[1]);

        let test_query = SectionQuery {
            section_id: None,
            name: None,
            description: None,
            contents: None,
            created_before: None,
            created_after: None,
            created_by: Some(String::from("Test@example.com")),
            sort: Some(String::from("description,desc(name)")),
            limit: Some(2),
            offset: Some(2),
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 1);
        assert_eq!(found_sections[0], test_sections[0]);
    }

    #[test]
    fn find_with_created_before_and_created_after() {
        let conn = get_test_db_connection();

        insert_test_sections(&conn);

        let test_query = SectionQuery {
            section_id: None,
            name: None,
            description: None,
            contents: None,
            created_before: None,
            created_after: Some("2099-01-01T00:00:00".parse::<NaiveDateTime>().unwrap()),
            created_by: Some(String::from("Test@example.com")),
            sort: None,
            limit: None,
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 0);

        let test_query = SectionQuery {
            section_id: None,
            name: None,
            description: None,
            contents: None,
            created_before: Some("2099-01-01T00:00:00".parse::<NaiveDateTime>().unwrap()),
            created_after: None,
            created_by: Some(String::from("Test@example.com")),
            sort: None,
            limit: None,
            offset: None,
        };

        let found_sections = SectionData::find(&conn, test_query).expect("Failed to find sections");

        assert_eq!(found_sections.len(), 3);
    }

    #[test]
    fn create_success() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);

        assert_eq!(test_section.name, "Kevin's Section");
        assert_eq!(
            test_section
                .description
                .expect("Created section missing description"),
            "Kevin made this section for testing"
        );
        assert_eq!(
            test_section
                .created_by
                .expect("Created section missing created_by"),
            "Kevin@example.com"
        );
    }

    #[test]
    fn create_failure_same_name() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);

        let copy_section = NewSection {
            name: test_section.name,
            description: test_section.description,
            contents: json!({"cells":[{"test1":"test"}]}),
            created_by: test_section.created_by,
        };

        let new_section = SectionData::create(&conn, copy_section);

        assert!(matches!(
            new_section,
            Err(
                diesel::result::Error::DatabaseError(
                    diesel::result::DatabaseErrorKind::UniqueViolation,
                    _,
                ),
            )
        ));
    }

    #[test]
    fn update_success() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);
        let test_report_section =
            insert_test_report_section_with_section_id(&conn, test_section.section_id);
        insert_test_run_report_failed_with_report_id(&conn, test_report_section.report_id);

        let changes = SectionChangeset {
            name: Some(String::from("TestTestTestTest")),
            description: Some(String::from("TESTTESTTESTTEST")),
            contents: Some(json!({"cells":[{"test1":"test"}]})),
        };

        let updated_section = SectionData::update(&conn, test_section.section_id, changes)
            .expect("Failed to update section");

        assert_eq!(updated_section.name, String::from("TestTestTestTest"));
        assert_eq!(
            updated_section.description.unwrap(),
            String::from("TESTTESTTESTTEST")
        );
    }

    #[test]
    fn update_failure_prohibited() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);
        let test_report_section =
            insert_test_report_section_with_section_id(&conn, test_section.section_id);
        insert_test_run_report_non_failed_with_report_id(&conn, test_report_section.report_id);

        let changes = SectionChangeset {
            name: Some(String::from("TestTestTestTest")),
            description: Some(String::from("TESTTESTTESTTEST")),
            contents: Some(json!({"cells":[{"test1":"test"}]})),
        };

        let updated_section = SectionData::update(&conn, test_section.section_id, changes);

        assert!(matches!(updated_section, Err(UpdateError::Prohibited(_))));
    }

    #[test]
    fn update_failure_same_name() {
        let conn = get_test_db_connection();

        let test_sections = insert_test_sections(&conn);

        let changes = SectionChangeset {
            name: Some(test_sections[0].name.clone()),
            description: None,
            contents: None,
        };

        let updated_section = SectionData::update(&conn, test_sections[1].section_id, changes);

        assert!(matches!(
            updated_section,
            Err(
                UpdateError::DB(
                    diesel::result::Error::DatabaseError(
                        diesel::result::DatabaseErrorKind::UniqueViolation,
                        _,
                    ),
                ),
            )
        ));
    }

    #[test]
    fn delete_success() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);

        let delete_result = SectionData::delete(&conn, test_section.section_id).unwrap();

        assert_eq!(delete_result, 1);

        let deleted_section = SectionData::find_by_id(&conn, test_section.section_id);

        assert!(matches!(
            deleted_section,
            Err(diesel::result::Error::NotFound)
        ));
    }

    #[test]
    fn delete_failure_foreign_key() {
        let conn = get_test_db_connection();

        let test_section = insert_test_section(&conn);
        insert_test_report_section_with_section_id(&conn, test_section.section_id);

        let delete_result = SectionData::delete(&conn, test_section.section_id);

        assert!(matches!(
            delete_result,
            Err(
                diesel::result::Error::DatabaseError(
                    diesel::result::DatabaseErrorKind::ForeignKeyViolation,
                    _,
                ),
            )
        ));
    }
}
